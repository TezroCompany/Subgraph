// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Approval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Approval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Approval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Approval", id.toString(), this);
    }
  }

  static load(id: string): Approval | null {
    return changetype<Approval | null>(store.get("Approval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class Burn extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Burn entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Burn must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Burn", id.toString(), this);
    }
  }

  static load(id: string): Burn | null {
    return changetype<Burn | null>(store.get("Burn", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount0(): BigInt {
    let value = this.get("amount0");
    return value!.toBigInt();
  }

  set amount0(value: BigInt) {
    this.set("amount0", Value.fromBigInt(value));
  }

  get amount1(): BigInt {
    let value = this.get("amount1");
    return value!.toBigInt();
  }

  set amount1(value: BigInt) {
    this.set("amount1", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class Mint extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Mint entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Mint must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Mint", id.toString(), this);
    }
  }

  static load(id: string): Mint | null {
    return changetype<Mint | null>(store.get("Mint", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount0(): BigInt {
    let value = this.get("amount0");
    return value!.toBigInt();
  }

  set amount0(value: BigInt) {
    this.set("amount0", Value.fromBigInt(value));
  }

  get amount1(): BigInt {
    let value = this.get("amount1");
    return value!.toBigInt();
  }

  set amount1(value: BigInt) {
    this.set("amount1", Value.fromBigInt(value));
  }
}

export class Swap extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Swap entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Swap must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Swap", id.toString(), this);
    }
  }

  static load(id: string): Swap | null {
    return changetype<Swap | null>(store.get("Swap", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get amount0In(): BigInt {
    let value = this.get("amount0In");
    return value!.toBigInt();
  }

  set amount0In(value: BigInt) {
    this.set("amount0In", Value.fromBigInt(value));
  }

  get amount1In(): BigInt {
    let value = this.get("amount1In");
    return value!.toBigInt();
  }

  set amount1In(value: BigInt) {
    this.set("amount1In", Value.fromBigInt(value));
  }

  get amount0Out(): BigInt {
    let value = this.get("amount0Out");
    return value!.toBigInt();
  }

  set amount0Out(value: BigInt) {
    this.set("amount0Out", Value.fromBigInt(value));
  }

  get amount1Out(): BigInt {
    let value = this.get("amount1Out");
    return value!.toBigInt();
  }

  set amount1Out(value: BigInt) {
    this.set("amount1Out", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class Sync extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Sync entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Sync must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Sync", id.toString(), this);
    }
  }

  static load(id: string): Sync | null {
    return changetype<Sync | null>(store.get("Sync", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get reserve0(): BigInt {
    let value = this.get("reserve0");
    return value!.toBigInt();
  }

  set reserve0(value: BigInt) {
    this.set("reserve0", Value.fromBigInt(value));
  }

  get reserve1(): BigInt {
    let value = this.get("reserve1");
    return value!.toBigInt();
  }

  set reserve1(value: BigInt) {
    this.set("reserve1", Value.fromBigInt(value));
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transfer", id.toString(), this);
    }
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class TopCornApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopCornApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopCornApproval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopCornApproval", id.toString(), this);
    }
  }

  static load(id: string): TopCornApproval | null {
    return changetype<TopCornApproval | null>(store.get("TopCornApproval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class TopCornTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopCornTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopCornTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopCornTransfer", id.toString(), this);
    }
  }

  static load(id: string): TopCornTransfer | null {
    return changetype<TopCornTransfer | null>(store.get("TopCornTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class BnbClaim extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BnbClaim entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BnbClaim must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BnbClaim", id.toString(), this);
    }
  }

  static load(id: string): BnbClaim | null {
    return changetype<BnbClaim | null>(store.get("BnbClaim", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get bnb(): BigInt {
    let value = this.get("bnb");
    return value!.toBigInt();
  }

  set bnb(value: BigInt) {
    this.set("bnb", Value.fromBigInt(value));
  }
}

export class Harvest extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Harvest entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Harvest must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Harvest", id.toString(), this);
    }
  }

  static load(id: string): Harvest | null {
    return changetype<Harvest | null>(store.get("Harvest", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get plots(): Array<BigInt> {
    let value = this.get("plots");
    return value!.toBigIntArray();
  }

  set plots(value: Array<BigInt>) {
    this.set("plots", Value.fromBigIntArray(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class LPClaim extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LPClaim entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LPClaim must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LPClaim", id.toString(), this);
    }
  }

  static load(id: string): LPClaim | null {
    return changetype<LPClaim | null>(store.get("LPClaim", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get withdrawals(): Array<BigInt> {
    let value = this.get("withdrawals");
    return value!.toBigIntArray();
  }

  set withdrawals(value: Array<BigInt>) {
    this.set("withdrawals", Value.fromBigIntArray(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }
}

export class TopcornAllocation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopcornAllocation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopcornAllocation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopcornAllocation", id.toString(), this);
    }
  }

  static load(id: string): TopcornAllocation | null {
    return changetype<TopcornAllocation | null>(
      store.get("TopcornAllocation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class TopcornClaim extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopcornClaim entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopcornClaim must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopcornClaim", id.toString(), this);
    }
  }

  static load(id: string): TopcornClaim | null {
    return changetype<TopcornClaim | null>(store.get("TopcornClaim", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get withdrawals(): Array<BigInt> {
    let value = this.get("withdrawals");
    return value!.toBigIntArray();
  }

  set withdrawals(value: Array<BigInt>) {
    this.set("withdrawals", Value.fromBigIntArray(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class LPDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LPDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LPDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LPDeposit", id.toString(), this);
    }
  }

  static load(id: string): LPDeposit | null {
    return changetype<LPDeposit | null>(store.get("LPDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }

  get seeds(): BigInt {
    let value = this.get("seeds");
    return value!.toBigInt();
  }

  set seeds(value: BigInt) {
    this.set("seeds", Value.fromBigInt(value));
  }
}

export class LPRemove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LPRemove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LPRemove must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LPRemove", id.toString(), this);
    }
  }

  static load(id: string): LPRemove | null {
    return changetype<LPRemove | null>(store.get("LPRemove", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get crates(): Array<BigInt> {
    let value = this.get("crates");
    return value!.toBigIntArray();
  }

  set crates(value: Array<BigInt>) {
    this.set("crates", Value.fromBigIntArray(value));
  }

  get crateLP(): Array<BigInt> {
    let value = this.get("crateLP");
    return value!.toBigIntArray();
  }

  set crateLP(value: Array<BigInt>) {
    this.set("crateLP", Value.fromBigIntArray(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }

  get stalkRemoved(): BigInt {
    let value = this.get("stalkRemoved");
    return value!.toBigInt();
  }

  set stalkRemoved(value: BigInt) {
    this.set("stalkRemoved", Value.fromBigInt(value));
  }

  get seedsRemoved(): BigInt {
    let value = this.get("seedsRemoved");
    return value!.toBigInt();
  }

  set seedsRemoved(value: BigInt) {
    this.set("seedsRemoved", Value.fromBigInt(value));
  }
}

export class TopcornRemove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopcornRemove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopcornRemove must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopcornRemove", id.toString(), this);
    }
  }

  static load(id: string): TopcornRemove | null {
    return changetype<TopcornRemove | null>(store.get("TopcornRemove", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get crates(): Array<BigInt> {
    let value = this.get("crates");
    return value!.toBigIntArray();
  }

  set crates(value: Array<BigInt>) {
    this.set("crates", Value.fromBigIntArray(value));
  }

  get crateTopcorns(): Array<BigInt> {
    let value = this.get("crateTopcorns");
    return value!.toBigIntArray();
  }

  set crateTopcorns(value: Array<BigInt>) {
    this.set("crateTopcorns", Value.fromBigIntArray(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }

  get stalkRemoved(): BigInt {
    let value = this.get("stalkRemoved");
    return value!.toBigInt();
  }

  set stalkRemoved(value: BigInt) {
    this.set("stalkRemoved", Value.fromBigInt(value));
  }

  get seedsRemoved(): BigInt {
    let value = this.get("seedsRemoved");
    return value!.toBigInt();
  }

  set seedsRemoved(value: BigInt) {
    this.set("seedsRemoved", Value.fromBigInt(value));
  }
}

export class Sow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Sow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Sow must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Sow", id.toString(), this);
    }
  }

  static load(id: string): Sow | null {
    return changetype<Sow | null>(store.get("Sow", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }

  get pods(): BigInt {
    let value = this.get("pods");
    return value!.toBigInt();
  }

  set pods(value: BigInt) {
    this.set("pods", Value.fromBigInt(value));
  }
}

export class PlotTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlotTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PlotTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PlotTransfer", id.toString(), this);
    }
  }

  static load(id: string): PlotTransfer | null {
    return changetype<PlotTransfer | null>(store.get("PlotTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get plotId(): BigInt {
    let value = this.get("plotId");
    return value!.toBigInt();
  }

  set plotId(value: BigInt) {
    this.set("plotId", Value.fromBigInt(value));
  }

  get pods(): BigInt {
    let value = this.get("pods");
    return value!.toBigInt();
  }

  set pods(value: BigInt) {
    this.set("pods", Value.fromBigInt(value));
  }
}

export class PodApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodApproval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodApproval", id.toString(), this);
    }
  }

  static load(id: string): PodApproval | null {
    return changetype<PodApproval | null>(store.get("PodApproval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get pods(): BigInt {
    let value = this.get("pods");
    return value!.toBigInt();
  }

  set pods(value: BigInt) {
    this.set("pods", Value.fromBigInt(value));
  }
}

export class PodListingCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodListingCancelled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodListingCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodListingCancelled", id.toString(), this);
    }
  }

  static load(id: string): PodListingCancelled | null {
    return changetype<PodListingCancelled | null>(
      store.get("PodListingCancelled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }
}

export class PodListingCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodListingCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodListingCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodListingCreated", id.toString(), this);
    }
  }

  static load(id: string): PodListingCreated | null {
    return changetype<PodListingCreated | null>(
      store.get("PodListingCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    return value!.toBigInt();
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get pricePerPod(): i32 {
    let value = this.get("pricePerPod");
    return value!.toI32();
  }

  set pricePerPod(value: i32) {
    this.set("pricePerPod", Value.fromI32(value));
  }

  get maxHarvestableIndex(): BigInt {
    let value = this.get("maxHarvestableIndex");
    return value!.toBigInt();
  }

  set maxHarvestableIndex(value: BigInt) {
    this.set("maxHarvestableIndex", Value.fromBigInt(value));
  }

  get toWallet(): boolean {
    let value = this.get("toWallet");
    return value!.toBoolean();
  }

  set toWallet(value: boolean) {
    this.set("toWallet", Value.fromBoolean(value));
  }
}

export class PodListingFilled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodListingFilled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodListingFilled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodListingFilled", id.toString(), this);
    }
  }

  static load(id: string): PodListingFilled | null {
    return changetype<PodListingFilled | null>(
      store.get("PodListingFilled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    return value!.toBigInt();
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class PodOrderCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodOrderCancelled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodOrderCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodOrderCancelled", id.toString(), this);
    }
  }

  static load(id: string): PodOrderCancelled | null {
    return changetype<PodOrderCancelled | null>(
      store.get("PodOrderCancelled", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value!.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }
}

export class PodOrderCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodOrderCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodOrderCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodOrderCreated", id.toString(), this);
    }
  }

  static load(id: string): PodOrderCreated | null {
    return changetype<PodOrderCreated | null>(store.get("PodOrderCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value!.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get pricePerPod(): i32 {
    let value = this.get("pricePerPod");
    return value!.toI32();
  }

  set pricePerPod(value: i32) {
    this.set("pricePerPod", Value.fromI32(value));
  }

  get maxPlaceInLine(): BigInt {
    let value = this.get("maxPlaceInLine");
    return value!.toBigInt();
  }

  set maxPlaceInLine(value: BigInt) {
    this.set("maxPlaceInLine", Value.fromBigInt(value));
  }
}

export class PodOrderFilled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodOrderFilled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodOrderFilled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodOrderFilled", id.toString(), this);
    }
  }

  static load(id: string): PodOrderFilled | null {
    return changetype<PodOrderFilled | null>(store.get("PodOrderFilled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get orderId(): Bytes {
    let value = this.get("orderId");
    return value!.toBytes();
  }

  set orderId(value: Bytes) {
    this.set("orderId", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    return value!.toBigInt();
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class Incentivization extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Incentivization entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Incentivization must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Incentivization", id.toString(), this);
    }
  }

  static load(id: string): Incentivization | null {
    return changetype<Incentivization | null>(store.get("Incentivization", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }

  get incentive(): BigInt {
    let value = this.get("incentive");
    return value!.toBigInt();
  }

  set incentive(value: BigInt) {
    this.set("incentive", Value.fromBigInt(value));
  }

  get feeInBnb(): BigInt {
    let value = this.get("feeInBnb");
    return value!.toBigInt();
  }

  set feeInBnb(value: BigInt) {
    this.set("feeInBnb", Value.fromBigInt(value));
  }
}

export class PodRateSnapshot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodRateSnapshot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodRateSnapshot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodRateSnapshot", id.toString(), this);
    }
  }

  static load(id: string): PodRateSnapshot | null {
    return changetype<PodRateSnapshot | null>(store.get("PodRateSnapshot", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get podRate(): BigInt {
    let value = this.get("podRate");
    return value!.toBigInt();
  }

  set podRate(value: BigInt) {
    this.set("podRate", Value.fromBigInt(value));
  }
}

export class SeasonOfPlenty extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SeasonOfPlenty entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SeasonOfPlenty must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SeasonOfPlenty", id.toString(), this);
    }
  }

  static load(id: string): SeasonOfPlenty | null {
    return changetype<SeasonOfPlenty | null>(store.get("SeasonOfPlenty", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get bnb(): BigInt {
    let value = this.get("bnb");
    return value!.toBigInt();
  }

  set bnb(value: BigInt) {
    this.set("bnb", Value.fromBigInt(value));
  }

  get harvestable(): BigInt {
    let value = this.get("harvestable");
    return value!.toBigInt();
  }

  set harvestable(value: BigInt) {
    this.set("harvestable", Value.fromBigInt(value));
  }
}

export class SeasonSnapshot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SeasonSnapshot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SeasonSnapshot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SeasonSnapshot", id.toString(), this);
    }
  }

  static load(id: string): SeasonSnapshot | null {
    return changetype<SeasonSnapshot | null>(store.get("SeasonSnapshot", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value!.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get supply(): BigInt {
    let value = this.get("supply");
    return value!.toBigInt();
  }

  set supply(value: BigInt) {
    this.set("supply", Value.fromBigInt(value));
  }

  get stalk(): BigInt {
    let value = this.get("stalk");
    return value!.toBigInt();
  }

  set stalk(value: BigInt) {
    this.set("stalk", Value.fromBigInt(value));
  }

  get seeds(): BigInt {
    let value = this.get("seeds");
    return value!.toBigInt();
  }

  set seeds(value: BigInt) {
    this.set("seeds", Value.fromBigInt(value));
  }

  get podIndex(): BigInt {
    let value = this.get("podIndex");
    return value!.toBigInt();
  }

  set podIndex(value: BigInt) {
    this.set("podIndex", Value.fromBigInt(value));
  }

  get harvestableIndex(): BigInt {
    let value = this.get("harvestableIndex");
    return value!.toBigInt();
  }

  set harvestableIndex(value: BigInt) {
    this.set("harvestableIndex", Value.fromBigInt(value));
  }

  get totalLiquidityUSD(): BigInt {
    let value = this.get("totalLiquidityUSD");
    return value!.toBigInt();
  }

  set totalLiquidityUSD(value: BigInt) {
    this.set("totalLiquidityUSD", Value.fromBigInt(value));
  }
}

export class Sunrise extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Sunrise entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Sunrise must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Sunrise", id.toString(), this);
    }
  }

  static load(id: string): Sunrise | null {
    return changetype<Sunrise | null>(store.get("Sunrise", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get caseId(): BigInt {
    let value = this.get("caseId");
    return value!.toBigInt();
  }

  set caseId(value: BigInt) {
    this.set("caseId", Value.fromBigInt(value));
  }

  get change(): i32 {
    let value = this.get("change");
    return value!.toI32();
  }

  set change(value: i32) {
    this.set("change", Value.fromI32(value));
  }

  get currentYield(): BigInt {
    let value = this.get("currentYield");
    return value!.toBigInt();
  }

  set currentYield(value: BigInt) {
    this.set("currentYield", Value.fromBigInt(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value!.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get newSoil(): BigInt {
    let value = this.get("newSoil");
    return value!.toBigInt();
  }

  set newSoil(value: BigInt) {
    this.set("newSoil", Value.fromBigInt(value));
  }

  get newHarvestable(): BigInt {
    let value = this.get("newHarvestable");
    return value!.toBigInt();
  }

  set newHarvestable(value: BigInt) {
    this.set("newHarvestable", Value.fromBigInt(value));
  }

  get newSilo(): BigInt {
    let value = this.get("newSilo");
    return value!.toBigInt();
  }

  set newSilo(value: BigInt) {
    this.set("newSilo", Value.fromBigInt(value));
  }

  get bnb(): BigInt {
    let value = this.get("bnb");
    return value!.toBigInt();
  }

  set bnb(value: BigInt) {
    this.set("bnb", Value.fromBigInt(value));
  }

  get harvestableSop(): BigInt {
    let value = this.get("harvestableSop");
    return value!.toBigInt();
  }

  set harvestableSop(value: BigInt) {
    this.set("harvestableSop", Value.fromBigInt(value));
  }

  get totalHarvestable(): BigInt {
    let value = this.get("totalHarvestable");
    return value!.toBigInt();
  }

  set totalHarvestable(value: BigInt) {
    this.set("totalHarvestable", Value.fromBigInt(value));
  }

  get totalNewTopcorns(): BigInt {
    let value = this.get("totalNewTopcorns");
    return value!.toBigInt();
  }

  set totalNewTopcorns(value: BigInt) {
    this.set("totalNewTopcorns", Value.fromBigInt(value));
  }

  get podRate(): BigInt {
    let value = this.get("podRate");
    return value!.toBigInt();
  }

  set podRate(value: BigInt) {
    this.set("podRate", Value.fromBigInt(value));
  }

  get supply(): BigInt {
    let value = this.get("supply");
    return value!.toBigInt();
  }

  set supply(value: BigInt) {
    this.set("supply", Value.fromBigInt(value));
  }

  get stalk(): BigInt {
    let value = this.get("stalk");
    return value!.toBigInt();
  }

  set stalk(value: BigInt) {
    this.set("stalk", Value.fromBigInt(value));
  }

  get seeds(): BigInt {
    let value = this.get("seeds");
    return value!.toBigInt();
  }

  set seeds(value: BigInt) {
    this.set("seeds", Value.fromBigInt(value));
  }

  get podIndex(): BigInt {
    let value = this.get("podIndex");
    return value!.toBigInt();
  }

  set podIndex(value: BigInt) {
    this.set("podIndex", Value.fromBigInt(value));
  }

  get harvestableIndex(): BigInt {
    let value = this.get("harvestableIndex");
    return value!.toBigInt();
  }

  set harvestableIndex(value: BigInt) {
    this.set("harvestableIndex", Value.fromBigInt(value));
  }

  get totalLiquidityUSD(): BigInt {
    let value = this.get("totalLiquidityUSD");
    return value!.toBigInt();
  }

  set totalLiquidityUSD(value: BigInt) {
    this.set("totalLiquidityUSD", Value.fromBigInt(value));
  }
}

export class SupplyDecrease extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SupplyDecrease entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SupplyDecrease must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SupplyDecrease", id.toString(), this);
    }
  }

  static load(id: string): SupplyDecrease | null {
    return changetype<SupplyDecrease | null>(store.get("SupplyDecrease", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value!.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get newSoil(): BigInt {
    let value = this.get("newSoil");
    return value!.toBigInt();
  }

  set newSoil(value: BigInt) {
    this.set("newSoil", Value.fromBigInt(value));
  }
}

export class SupplyIncrease extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SupplyIncrease entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SupplyIncrease must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SupplyIncrease", id.toString(), this);
    }
  }

  static load(id: string): SupplyIncrease | null {
    return changetype<SupplyIncrease | null>(store.get("SupplyIncrease", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value!.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get newHarvestable(): BigInt {
    let value = this.get("newHarvestable");
    return value!.toBigInt();
  }

  set newHarvestable(value: BigInt) {
    this.set("newHarvestable", Value.fromBigInt(value));
  }

  get newSilo(): BigInt {
    let value = this.get("newSilo");
    return value!.toBigInt();
  }

  set newSilo(value: BigInt) {
    this.set("newSilo", Value.fromBigInt(value));
  }

  get newSoil(): BigInt {
    let value = this.get("newSoil");
    return value!.toBigInt();
  }

  set newSoil(value: BigInt) {
    this.set("newSoil", Value.fromBigInt(value));
  }
}

export class SupplyNeutral extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SupplyNeutral entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SupplyNeutral must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SupplyNeutral", id.toString(), this);
    }
  }

  static load(id: string): SupplyNeutral | null {
    return changetype<SupplyNeutral | null>(store.get("SupplyNeutral", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get newSoil(): BigInt {
    let value = this.get("newSoil");
    return value!.toBigInt();
  }

  set newSoil(value: BigInt) {
    this.set("newSoil", Value.fromBigInt(value));
  }
}

export class WeatherChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WeatherChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type WeatherChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("WeatherChange", id.toString(), this);
    }
  }

  static load(id: string): WeatherChange | null {
    return changetype<WeatherChange | null>(store.get("WeatherChange", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get caseId(): BigInt {
    let value = this.get("caseId");
    return value!.toBigInt();
  }

  set caseId(value: BigInt) {
    this.set("caseId", Value.fromBigInt(value));
  }

  get change(): i32 {
    let value = this.get("change");
    return value!.toI32();
  }

  set change(value: i32) {
    this.set("change", Value.fromI32(value));
  }

  get currentYield(): BigInt {
    let value = this.get("currentYield");
    return value!.toBigInt();
  }

  set currentYield(value: BigInt) {
    this.set("currentYield", Value.fromBigInt(value));
  }
}

export class SiloFacetLPDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SiloFacetLPDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloFacetLPDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloFacetLPDeposit", id.toString(), this);
    }
  }

  static load(id: string): SiloFacetLPDeposit | null {
    return changetype<SiloFacetLPDeposit | null>(
      store.get("SiloFacetLPDeposit", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }

  get seeds(): BigInt {
    let value = this.get("seeds");
    return value!.toBigInt();
  }

  set seeds(value: BigInt) {
    this.set("seeds", Value.fromBigInt(value));
  }
}

export class SiloFacetLPRemove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SiloFacetLPRemove entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloFacetLPRemove must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloFacetLPRemove", id.toString(), this);
    }
  }

  static load(id: string): SiloFacetLPRemove | null {
    return changetype<SiloFacetLPRemove | null>(
      store.get("SiloFacetLPRemove", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get crates(): Array<BigInt> {
    let value = this.get("crates");
    return value!.toBigIntArray();
  }

  set crates(value: Array<BigInt>) {
    this.set("crates", Value.fromBigIntArray(value));
  }

  get crateLP(): Array<BigInt> {
    let value = this.get("crateLP");
    return value!.toBigIntArray();
  }

  set crateLP(value: Array<BigInt>) {
    this.set("crateLP", Value.fromBigIntArray(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }

  get stalkRemoved(): BigInt {
    let value = this.get("stalkRemoved");
    return value!.toBigInt();
  }

  set stalkRemoved(value: BigInt) {
    this.set("stalkRemoved", Value.fromBigInt(value));
  }

  get seedsRemoved(): BigInt {
    let value = this.get("seedsRemoved");
    return value!.toBigInt();
  }

  set seedsRemoved(value: BigInt) {
    this.set("seedsRemoved", Value.fromBigInt(value));
  }
}

export class LPWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LPWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LPWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LPWithdraw", id.toString(), this);
    }
  }

  static load(id: string): LPWithdraw | null {
    return changetype<LPWithdraw | null>(store.get("LPWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }
}

export class SiloFacetTopcornAllocation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SiloFacetTopcornAllocation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloFacetTopcornAllocation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloFacetTopcornAllocation", id.toString(), this);
    }
  }

  static load(id: string): SiloFacetTopcornAllocation | null {
    return changetype<SiloFacetTopcornAllocation | null>(
      store.get("SiloFacetTopcornAllocation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class TopcornDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopcornDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopcornDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopcornDeposit", id.toString(), this);
    }
  }

  static load(id: string): TopcornDeposit | null {
    return changetype<TopcornDeposit | null>(store.get("TopcornDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class SiloFacetTopcornRemove extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SiloFacetTopcornRemove entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloFacetTopcornRemove must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloFacetTopcornRemove", id.toString(), this);
    }
  }

  static load(id: string): SiloFacetTopcornRemove | null {
    return changetype<SiloFacetTopcornRemove | null>(
      store.get("SiloFacetTopcornRemove", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get crates(): Array<BigInt> {
    let value = this.get("crates");
    return value!.toBigIntArray();
  }

  set crates(value: Array<BigInt>) {
    this.set("crates", Value.fromBigIntArray(value));
  }

  get crateTopcorns(): Array<BigInt> {
    let value = this.get("crateTopcorns");
    return value!.toBigIntArray();
  }

  set crateTopcorns(value: Array<BigInt>) {
    this.set("crateTopcorns", Value.fromBigIntArray(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }

  get stalkRemoved(): BigInt {
    let value = this.get("stalkRemoved");
    return value!.toBigInt();
  }

  set stalkRemoved(value: BigInt) {
    this.set("stalkRemoved", Value.fromBigInt(value));
  }

  get seedsRemoved(): BigInt {
    let value = this.get("seedsRemoved");
    return value!.toBigInt();
  }

  set seedsRemoved(value: BigInt) {
    this.set("seedsRemoved", Value.fromBigInt(value));
  }
}

export class TopcornWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopcornWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopcornWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopcornWithdraw", id.toString(), this);
    }
  }

  static load(id: string): TopcornWithdraw | null {
    return changetype<TopcornWithdraw | null>(store.get("TopcornWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get topcorns(): BigInt {
    let value = this.get("topcorns");
    return value!.toBigInt();
  }

  set topcorns(value: BigInt) {
    this.set("topcorns", Value.fromBigInt(value));
  }
}

export class Pause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pause entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pause must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Pause", id.toString(), this);
    }
  }

  static load(id: string): Pause | null {
    return changetype<Pause | null>(store.get("Pause", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Unpause extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unpause entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Unpause must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Unpause", id.toString(), this);
    }
  }

  static load(id: string): Unpause | null {
    return changetype<Unpause | null>(store.get("Unpause", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get timePassed(): BigInt {
    let value = this.get("timePassed");
    return value!.toBigInt();
  }

  set timePassed(value: BigInt) {
    this.set("timePassed", Value.fromBigInt(value));
  }
}

export class PodListing extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodListing entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodListing must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodListing", id.toString(), this);
    }
  }

  static load(id: string): PodListing | null {
    return changetype<PodListing | null>(store.get("PodListing", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    return value!.toBigInt();
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get maxHarvestableIndex(): BigInt {
    let value = this.get("maxHarvestableIndex");
    return value!.toBigInt();
  }

  set maxHarvestableIndex(value: BigInt) {
    this.set("maxHarvestableIndex", Value.fromBigInt(value));
  }

  get pricePerPod(): i32 {
    let value = this.get("pricePerPod");
    return value!.toI32();
  }

  set pricePerPod(value: i32) {
    this.set("pricePerPod", Value.fromI32(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get expiresIn(): BigInt {
    let value = this.get("expiresIn");
    return value!.toBigInt();
  }

  set expiresIn(value: BigInt) {
    this.set("expiresIn", Value.fromBigInt(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }
}

export class PodOrder extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PodOrder entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PodOrder must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PodOrder", id.toString(), this);
    }
  }

  static load(id: string): PodOrder | null {
    return changetype<PodOrder | null>(store.get("PodOrder", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get maxPlaceInLine(): BigInt {
    let value = this.get("maxPlaceInLine");
    return value!.toBigInt();
  }

  set maxPlaceInLine(value: BigInt) {
    this.set("maxPlaceInLine", Value.fromBigInt(value));
  }

  get PlaceInLineFrom(): BigInt {
    let value = this.get("PlaceInLineFrom");
    return value!.toBigInt();
  }

  set PlaceInLineFrom(value: BigInt) {
    this.set("PlaceInLineFrom", Value.fromBigInt(value));
  }

  get PlaceInLineTo(): BigInt {
    let value = this.get("PlaceInLineTo");
    return value!.toBigInt();
  }

  set PlaceInLineTo(value: BigInt) {
    this.set("PlaceInLineTo", Value.fromBigInt(value));
  }

  get pricePerPod(): i32 {
    let value = this.get("pricePerPod");
    return value!.toI32();
  }

  set pricePerPod(value: i32) {
    this.set("pricePerPod", Value.fromI32(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }
}

export class HelperMarketplace extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HelperMarketplace entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HelperMarketplace must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HelperMarketplace", id.toString(), this);
    }
  }

  static load(id: string): HelperMarketplace | null {
    return changetype<HelperMarketplace | null>(
      store.get("HelperMarketplace", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get harvestableIndex(): BigInt {
    let value = this.get("harvestableIndex");
    return value!.toBigInt();
  }

  set harvestableIndex(value: BigInt) {
    this.set("harvestableIndex", Value.fromBigInt(value));
  }

  get listings(): Array<string> {
    let value = this.get("listings");
    return value!.toStringArray();
  }

  set listings(value: Array<string>) {
    this.set("listings", Value.fromStringArray(value));
  }

  get orders(): Array<string> {
    let value = this.get("orders");
    return value!.toStringArray();
  }

  set orders(value: Array<string>) {
    this.set("orders", Value.fromStringArray(value));
  }
}

export class SiloDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SiloDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloDeposit", id.toString(), this);
    }
  }

  static load(id: string): SiloDeposit | null {
    return changetype<SiloDeposit | null>(store.get("SiloDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get topcorn(): BigInt {
    let value = this.get("topcorn");
    return value!.toBigInt();
  }

  set topcorn(value: BigInt) {
    this.set("topcorn", Value.fromBigInt(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }

  get seedsLp(): BigInt {
    let value = this.get("seedsLp");
    return value!.toBigInt();
  }

  set seedsLp(value: BigInt) {
    this.set("seedsLp", Value.fromBigInt(value));
  }

  get stalksLp(): BigInt {
    let value = this.get("stalksLp");
    return value!.toBigInt();
  }

  set stalksLp(value: BigInt) {
    this.set("stalksLp", Value.fromBigInt(value));
  }

  get seedsTopcorn(): BigInt {
    let value = this.get("seedsTopcorn");
    return value!.toBigInt();
  }

  set seedsTopcorn(value: BigInt) {
    this.set("seedsTopcorn", Value.fromBigInt(value));
  }

  get stalksTopcorn(): BigInt {
    let value = this.get("stalksTopcorn");
    return value!.toBigInt();
  }

  set stalksTopcorn(value: BigInt) {
    this.set("stalksTopcorn", Value.fromBigInt(value));
  }

  get seeds(): BigInt {
    let value = this.get("seeds");
    return value!.toBigInt();
  }

  set seeds(value: BigInt) {
    this.set("seeds", Value.fromBigInt(value));
  }

  get stalks(): BigInt {
    let value = this.get("stalks");
    return value!.toBigInt();
  }

  set stalks(value: BigInt) {
    this.set("stalks", Value.fromBigInt(value));
  }
}

export class SiloWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SiloWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SiloWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SiloWithdraw", id.toString(), this);
    }
  }

  static load(id: string): SiloWithdraw | null {
    return changetype<SiloWithdraw | null>(store.get("SiloWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get topcorn(): BigInt {
    let value = this.get("topcorn");
    return value!.toBigInt();
  }

  set topcorn(value: BigInt) {
    this.set("topcorn", Value.fromBigInt(value));
  }

  get lp(): BigInt {
    let value = this.get("lp");
    return value!.toBigInt();
  }

  set lp(value: BigInt) {
    this.set("lp", Value.fromBigInt(value));
  }
}
